"""
Module containing mixin class for BaseEnrtRecipe class that enables flow
steering across test device queues using steering rules.

Copyright 2025 Red Hat, Inc.
Licensed under the GNU General Public License, version 2 as
published by the Free Software Foundation; see COPYING for details.
"""

__author__ = """
sdobron@redhat.com (Samuel Dobron)
"""


from collections.abc import Iterable
import re
import logging
from lnst.Common.IpAddress import ipaddress
from typing import Literal, Optional, Any
from lnst.Common.IpAddress import Ip4Address
from lnst.Common.LnstError import LnstError
from lnst.Devices.Device import Device

from lnst.Common.Parameters import StrParam, ChoiceParam
from lnst.RecipeCommon.Perf.Measurements.BaseFlowMeasurement import Flow
from lnst.RecipeCommon.Perf.PerfTestMixins import BasePerfTestTweakMixin
from lnst.RecipeCommon.Perf.Measurements.BaseFlowMeasurement import BaseFlowMeasurement


class DevFlowsPinningMixin(BasePerfTestTweakMixin):
    """
    This class is an extension to the :any:`BaseEnrtRecipe` class that
    enables flow steering across test device queues. Generated flows
    are iterated and pinned to
    :attr:`lnst.RecipeCommon.Perf.Measurements.BaseFlowMeasurement.Flow.receiver_cpupin`
    CPU queue. Flow steering "keys" are configurable by `steer_flows_by` recipe
    parameter (for all the flows) OR by overriding the :meth:`.steer_flow_by` method
    for setting steering "keys" independently per flow.

    This is useful especially for cases, when user don't want to rely
    on rx hash algorithm to steer packets to the right CPU queue and
    want to pin them manually.
    Basically, just more-granular Receive side scaling. See
    https://man7.org/linux/man-pages/man8/ethtool.8.html

    Can be "partially" used by pinning just selected flows and keeping
    the rest unpinned - so they'll be steered by rx hash algorithm just
    by returning `None` in :meth:`.steer_flow_by` method for unpinned flow.

    This mixin does NOT pin IRQs to
    :attr:`lnst.RecipeCommon.Perf.Measurements.BaseFlowMeasurement.Flow.receiver_cpupin`
    CPUs, which is required for optimal performance. IRQs can be pinned
    e.g. by our other mixin :class:`lnst.Recipes.ENRT.ConfigMixins.DevInterruptHWConfigMixin`
    or :class:`lnst.Recipes.ENRT.ConfigMixins.MultiDevInterruptPinningHWConfigMixin`.
    """

    steer_flows_by = ChoiceParam(
        type=StrParam, choices={"dst-ip", "src-ip", "dst-port", "src-port"}
    )

    def apply_perf_test_tweak(self, perf_config):
        """
        Pins flows generated by
        :meth:`BaseFlowMeasurementGenerator.generate_flow_combinations`
        to CPU queues by using `ethtool -N ... flow-type...` command.

        Internal configuration is stored in
        :any:`EnrtConfiguration.perf_test_tweak_config["flow_steering_rules"]`.
        """
        super().apply_perf_test_tweak(perf_config)

        perf_config.perf_test_tweak_config["flow_steering_rules"] = {}

        for measurement in [
            measurement
            for measurement in perf_config.measurements
            if isinstance(measurement, BaseFlowMeasurement)
        ]:
            for flow in measurement.flows:
                if self.steer_flow_by(flow) is None:
                    continue  # skip unpinned flow

                for steering_nic in self.steer_flow_to(flow):
                    perf_config.perf_test_tweak_config[
                        "flow_steering_rules"
                    ].setdefault(steering_nic, [])

                    perf_config.perf_test_tweak_config["flow_steering_rules"][
                        steering_nic
                    ].append(self._pin_flow(flow, steering_nic))

    def _pin_flow(self, flow: Flow, steering_nic: Device) -> tuple[str, str]:
        """
        Method pins :param:`flow` to :any:`Flow.receiver_cpupin`.
        Pinning is done by `ethtool -N ... flow-type ... action`,
        not by `queue`. So other actions (by <0 action code) can
        be specified as well.
        See https://man7.org/linux/man-pages/man8/ethtool.8.html

        :param flow: flow object to pin
        :param steering_nic: NIC where the flow should be pinned

        :returns: tuple of rule ID (for deconfig) and description of pinning.
            That can't be dynamically generated in :meth:`.describe_hw_config`
            as it woudln't know which flow belongs to which rule ID.
        """
        cpupin = flow.receiver_cpupin
        if len(cpupin) > 1:
            logging.warning(
                "Flow is pinned to multiple CPUs.\
            Why? Usual rx-hash algos will throw packets from \
            the same flow to the same queue anyway (based on its' 5-tuple)."
            )

            logging.warning(f"Using only the first CPU: {cpupin[0]}")

        steer_by = self.steer_flow_by(flow)
        flow_type = self._get_flow_type(flow, steer_by)
        steering_key = self._get_steering_key(flow, steer_by)

        job = steering_nic.netns.run(
            f"ethtool -N {steering_nic.name} flow-type "
            f"{flow_type} {steer_by} "
            f"{steering_key} action {cpupin[0]}"
        )
        if not job.passed:
            raise LnstError("Failed to pin flow to CPU.")

        desc = f"{flow} is pinned at {steering_nic} to queue {cpupin[0]} by {steer_by} ({steering_key})"

        return self.rule_id_from_job(job), desc

    @staticmethod
    def rule_id_from_job(job) -> str:
        """
        If your driver returns rule ID in some other format,
        you should override this method. It's later used
        for removing the rule.
        """
        return re.search(r"Added rule with ID (\d+)", job.stdout).group(1)

    def _get_steering_key(self, flow: Flow, steer_by) -> Any:
        """
        Returns a value based on which should the flow be steered.

        E.g. if :attr:`flow.steer_by` is "src-ip", it returns
        :attr:`flow.generator_bind` IP address.

        :param flow: flow object to pin
        :returns: steering key
        """
        if steer_by == "src-ip":
            return flow.generator_bind
        elif steer_by == "dst-ip":
            return flow.receiver_bind
        elif steer_by == "src-port":
            return flow.generator_port
        elif steer_by == "dst-port":
            return flow.receiver_port
        else:
            raise NotImplementedError(
                f"Flow steering by {steer_by} not implemented (yet)."
            )

    def _get_flow_type(self, flow: Flow, steer_by) -> str:
        """
        Returns flow protocol based on which steering is done.
        E.g.
            if steering by IP, it returns "ip4" or "ip6".
            if steering by TCP, it returns "tcp4" or "tcp6".

        :param flow: flow object to pin
        :returns: flow protocol+IP version
        """
        ip_version = (
            "4" if isinstance(ipaddress(flow.receiver_bind), Ip4Address) else "6"
        )

        protocol = None
        if "ip" in steer_by:  # e.g. src-ip, dst-ip
            protocol = "ip"

        elif "port" in steer_by:  # e.g. src-port, dst-port
            if "tcp" in flow.type:
                protocol = "tcp"
            elif "sctp" in flow.type:
                protocol = "sctp"
            elif "udp" in flow.type or "xdp" in flow.type:  # xdp tests uses udp
                protocol = "udp"
            else:
                raise NotImplementedError(
                    f"Flow steering for {flow.type} not implemented (yet)."
                )
        else:
            raise NotImplementedError(
                f"Flow steering by {steer_by} not implemented (yet)."
            )

        return protocol + ip_version

    def remove_perf_test_tweak(self, perf_config):
        if "flow_steering_rules" in perf_config.perf_test_tweak_config:
            for nic, rules in perf_config.perf_test_tweak_config[
                "flow_steering_rules"
            ].items():
                for id, _ in rules:
                    nic.netns.run(f"ethtool -N {nic.name} delete {id}")
                    # ^ remove steering rule

        super().remove_perf_test_tweak(perf_config)

    def steer_flow_by(
        self, flow
    ) -> Optional[Literal["dst-ip", "src-ip", "dst-port", "src-port"]]:
        """
        This method should return an steering key, based on
        which the flow should be steered across the queues.
        E.g. if steering by src-ip, it returns "src-ip" and
        the flow will be steered based on its' source IP address.
        By default, it returns recipe the value of recipe parameter
        steer_flows_by, which means all the flows uses the same
        steering key.

        If None is returned, flow won't be steered.

        :param flow: flow object to pin
        :returns: steering key
        """
        return getattr(self.params, "steer_flows_by", None)

    def steer_flow_to(self, flow) -> Iterable[Device]:
        """
        This methos can be used to override the default
        NIC(s) where steering should be set.
        By default, it's the receiver machine but if flow
        passes through multiple machines, steering can be
        set for all of them, depends on usage.

        :param flow: flow object to pin
        :returns: list of NICs where steering should be set
        """
        return [flow.receiver_nic]

    def generate_perf_test_tweak_description(self, perf_config):
        desc = super().generate_perf_test_tweak_description(perf_config)

        hw_config = perf_config.perf_test_tweak_config

        for nic, rules in hw_config["flow_steering_rules"].items():
            desc.append(f"Steered flows on {nic.name}:")
            for id, rule in rules:
                desc.append(f"{rule} (rule: {id})")

        return desc
