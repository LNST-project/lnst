from collections.abc import Iterator, Collection
import itertools

from lnst.Common.Parameters import (
    Param,
    IntParam,
    ListParam,
    StrParam,
    ChoiceParam,
)

from lnst.Common.IpAddress import ip_version_string
from lnst.RecipeCommon.Perf.Measurements import Flow as PerfFlow
from lnst.RecipeCommon.Perf.Measurements import (
    IperfFlowMeasurement,
    NeperFlowMeasurement,
)
from lnst.RecipeCommon.endpoints import EndpointPair, IPEndpoint
from lnst.Recipes.ENRT.BaseEnrtRecipe import EnrtConfiguration

from lnst.Recipes.ENRT.MeasurementGenerators.BaseMeasurementGenerator import BaseMeasurementGenerator


MEASUREMENT_LOOKUP = {
    'iperf': IperfFlowMeasurement,
    'neper': NeperFlowMeasurement,
}

class BaseFlowMeasurementGenerator(BaseMeasurementGenerator):
    """
    :param net_perf_tool:
        Parameter used by the :any:`generate_perf_configurations` generator to
        create a PerfRecipeConf object.
        Specifies a string name that maps to a network flow measurement class
        that accepts :any:`PerfFlow` objects and can be used to measure those specified flows.
        Supported options are 'iperf' or 'neper'
    :type net_perf_tool: :any:`ChoiceParam` (default 'iperf' )

    :param perf_tests:
        Parameter used by the :any:`generate_flow_combinations` generator.
        Tells the generator what types of network flow measurements to generate
        perf test configurations for.
    :type perf_tests: Tuple[str] (default ("tcp_stream", "udp_stream",
        "sctp_stream"))

    :param perf_duration:
        Parameter used by the :any:`generate_perf_configurations` generator. To
        specify the duration of the performance measurements, in seconds.
    :type perf_duration: :any:`IntParam` (default 60)

    :param perf_parallel_streams:
        Parameter used by the :any:`generate_flow_combinations` generator. To
        specify how many parallel streams of the same network flow should be
        measured at the same time.
    :type perf_parallel_streams: :any:`IntParam` (default 1)

    :param perf_parallel_processes:
        Parameter used by the :any:`generate_flow_combinations` generator. To
        specify how many parallel net_perf_tool processes of the same network flow
        should be measured at the same time.
    :type perf_parallel_processes: :any:`IntParam` (default 1)

    :param perf_msg_sizes:
        Parameter used by the :any:`generate_flow_combinations` generator. To
        specify what different message sizes (in bytes) used generated for the
        network flow should be tested - each message size resulting in a
        separate performance measurement.
    :type perf_msg_sizes: list[int] (default [123])
    """

    # common perf test params
    perf_tests = Param(default=("tcp_stream", "udp_stream", "sctp_stream"))
    perf_duration = IntParam(default=60)
    perf_parallel_streams = IntParam(default=1)
    perf_parallel_processes = IntParam(default=1)
    perf_msg_sizes = ListParam(default=[123])
    perf_warmup_duration = IntParam(default=0, mandatory=False)

    net_perf_tool = ChoiceParam(type=StrParam, choices=MEASUREMENT_LOOKUP.keys(), default='iperf')

    @property
    def net_perf_tool_class(self):
        cls = self.params.get('net_perf_tool', None)
        if cls is None:
            return IperfFlowMeasurement
        else:
            return MEASUREMENT_LOOKUP[cls]

    def generate_perf_measurements_combinations(self, config):
        combinations = super().generate_perf_measurements_combinations(config)
        for flow_combination in self.generate_flow_combinations(config):
            combinations.append([self.net_perf_tool_class(flow_combination, recipe_conf=config)])
        return combinations

    def generate_flow_combinations(self, config) -> Iterator[list[PerfFlow]]:
        """Base flow combination generator

        The generator loops over all endpoint pairs to test performance between
        (generated by the :any:`generate_perf_endpoints` method) then over all
        the selected :any:`ip_versions` and uses the first IP address fitting
        these criteria. Then the generator loops over the selected performance
        tests as selected via :any:`perf_tests`, then message sizes from
        :any:`msg_sizes`.

        :return: list of Flow combinations to measure in parallel
        :rtype: Iterator[:any:`PerfFlow`]
        """
        for parallel_endpoint_pairs in self.generate_perf_endpoints(config):
            for ip_version in self.params.ip_versions:
                filtered_parallel_endpoints = [
                    endpoint_pair
                    for endpoint_pair in parallel_endpoint_pairs
                    if ip_version_string(endpoint_pair.first.address) == ip_version
                ]

                # skip test if no endpoints left after ip filtering
                if not filtered_parallel_endpoints:
                    continue

                for perf_test in self.params.perf_tests:
                    for size in self.params.perf_msg_sizes:
                        yield self._create_perf_flows(
                            filtered_parallel_endpoints,
                            perf_test,
                            size,
                        )

    def generate_perf_endpoints(self, config: EnrtConfiguration) -> list[Collection[EndpointPair[IPEndpoint]]]:
        """
        Returns sequential list of parallel endpoint-pairs that should be performance-tested.
        """
        return []

    def _create_perf_flows(
        self,
        endpoint_pairs: list[EndpointPair[IPEndpoint]],
        perf_test: str,
        msg_size,
    ) -> list[PerfFlow]:
        port_iter = itertools.count(12000)

        flows = []
        for endpoint_pair in endpoint_pairs:
            client, server = endpoint_pair
            for i in range(self.params.perf_parallel_processes):
                server_port = client_port = next(port_iter)
                flows.append(
                    self._create_perf_flow(
                        perf_test,
                        client.device,
                        client.address,
                        client_port if perf_test != "mptcp_stream" else None,
                        server.device,
                        server.address,
                        server_port,
                        msg_size,
                        self.generator_cpupin(i),
                        self.receiver_cpupin(i),
                    )
                )

        return flows

    def generator_cpupin(self, process_no):
        """
        This method returns a list of cpus that will be used for CPU pinning
        of the flow generator. The method should be defined by derived class.
        """
        return None

    def receiver_cpupin(self, process_no):
        """
        This method returns a list of cpus that will be used for CPU pinning
        of the flow receiver. The method should be defined by derived class.
        """
        return None

    def _cpupin_based_on_policy(self, process_no=None, cpus=None, cpu_policy=None):
        """
        This is a helper method for any derived class that can be used by
        :any:`generator_cpupin` and :any:`receiver_cpupin` to generate
        a subset of `cpus` based on the `cpu_policy` and `process_no` parameters.

        :param process_no:
            This integer is used as wrapped index to the `cpus` list if
            `cpu_policy` is set to "round-robin". Typically a flow measurement
            generator iterates over the number of perf measurement tool instances
            and the iterator value is used as `process_no`

        :param cpus:
            A list of cpu ids available to select by `cpu_policy`

        :param cpu_policy:
            Can be set to following values:
            * "round-robin" - list containing single cpu with index `process_no`
            in the list defined by `cpus` is returned
            * "all" - complete list defined by the `cpus` is returned
        """
        if process_no is None:
            return None

        if not cpus:
            return None

        if not cpu_policy:
            return cpus

        if cpu_policy == 'round-robin':
            return [cpus[process_no % len(cpus)]]
        elif cpu_policy == 'all':
            return cpus
        else:
            raise Exception(f'Unknown cpu_policy {cpu_policy}')

    def _create_perf_flow(
        self,
        perf_test,
        client_nic,
        client_bind,
        client_port,
        server_nic,
        server_bind,
        server_port,
        msg_size,
        generator_cpupin,
        receiver_cpupin,
    ) -> PerfFlow:
        """
        Wrapper to create a PerfFlow. Mixins that want to change this behavior (for example, to reverse the direction)
        can override this method as an alternative to overriding :any:`generate_flow_combinations`
        """
        return PerfFlow(
            type=perf_test,
            generator=client_nic.netns,
            generator_bind=client_bind,
            generator_nic=client_nic,
            generator_port=client_port,
            receiver=server_nic.netns,
            receiver_bind=server_bind,
            receiver_nic=server_nic,
            receiver_port=server_port,
            msg_size=msg_size,
            duration=self.params.perf_duration,
            warmup_duration=self.params.perf_warmup_duration,
            parallel_streams=self.params.perf_parallel_streams,
            generator_cpupin=generator_cpupin,
            receiver_cpupin=receiver_cpupin,
        )
