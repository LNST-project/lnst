from typing import List

from lnst.Common.Parameters import (
    Param,
    IntParam,
    ListParam,
    StrParam,
    ChoiceParam,
)
from lnst.Common.IpAddress import AF_INET, AF_INET6

from lnst.RecipeCommon.Perf.Measurements import Flow as PerfFlow
from lnst.RecipeCommon.Perf.Measurements import IperfFlowMeasurement, NeperFlowMeasurement

from lnst.Recipes.ENRT.MeasurementGenerators.BaseMeasurementGenerator import BaseMeasurementGenerator



MEASUREMENT_LOOKUP = {
    'iperf': IperfFlowMeasurement,
    'neper': NeperFlowMeasurement,
}

class BaseFlowMeasurementGenerator(BaseMeasurementGenerator):
    """
    :param net_perf_tool:
        Parameter used by the :any:`generate_perf_configurations` generator to
        create a PerfRecipeConf object.
        Specifies a string name that maps to a network flow measurement class
        that accepts :any:`PerfFlow` objects and can be used to measure those specified flows.
        Supported options are 'iperf' or 'neper'
    :type net_perf_tool: :any:`ChoiceParam` (default 'iperf' )

    :param perf_tests:
        Parameter used by the :any:`generate_flow_combinations` generator.
        Tells the generator what types of network flow measurements to generate
        perf test configurations for.
    :type perf_tests: Tuple[str] (default ("tcp_stream", "udp_stream",
        "sctp_stream"))

    :param perf_duration:
        Parameter used by the :any:`generate_perf_configurations` generator. To
        specify the duration of the performance measurements, in seconds.
    :type perf_duration: :any:`IntParam` (default 60)

    :param perf_iterations:
        Parameter used by the :any:`generate_perf_configurations` generator. To
        specify how many times should each performance measurement be repeated
        to generate cumulative results which can be statistically analyzed.
    :type perf_iterations: :any:`IntParam` (default 5)

    :param perf_parallel_streams:
        Parameter used by the :any:`generate_flow_combinations` generator. To
        specify how many parallel streams of the same network flow should be
        measured at the same time.
    :type perf_parallel_streams: :any:`IntParam` (default 1)

    :param perf_parallel_processes:
        Parameter used by the :any:`generate_flow_combinations` generator. To
        specify how many parallel net_perf_tool processes of the same network flow
        should be measured at the same time.
    :type perf_parallel_processes: :any:`IntParam` (default 1)

    :param perf_msg_sizes:
        Parameter used by the :any:`generate_flow_combinations` generator. To
        specify what different message sizes (in bytes) used generated for the
        network flow should be tested - each message size resulting in a
        separate performance measurement.
    :type perf_msg_sizes: List[Int] (default [123])
    """

    # common perf test params
    perf_tests = Param(default=("tcp_stream", "udp_stream", "sctp_stream"))
    perf_duration = IntParam(default=60)
    perf_iterations = IntParam(default=5)
    perf_parallel_streams = IntParam(default=1)
    perf_parallel_processes = IntParam(default=1)
    perf_msg_sizes = ListParam(default=[123])
    perf_warmup_duration = IntParam(default=0, mandatory=False)

    net_perf_tool = ChoiceParam(type=StrParam, choices=MEASUREMENT_LOOKUP.keys(), default='iperf')

    @property
    def net_perf_tool_class(self):
        cls = self.params.get('net_perf_tool', None)
        if cls is None:
            return IperfFlowMeasurement
        else:
            return MEASUREMENT_LOOKUP[cls]

    def generate_perf_measurements_combinations(self, config):
        combinations = super().generate_perf_measurements_combinations(config)
        for flow_combination in self.generate_flow_combinations(config):
            combinations.append([self.net_perf_tool_class(flow_combination)])
        return combinations

    def generate_flow_combinations(self, config):
        """Base flow combination generator

        The generator loops over all endpoint pairs to test performance between
        (generated by the :any:`generate_perf_endpoints` method) then over all
        the selected :any:`ip_versions` and uses the first IP address fitting
        these criteria. Then the generator loops over the selected performance
        tests as selected via :any:`perf_tests`, then message sizes from
        :any:`msg_sizes`.

        :return: list of Flow combinations to measure in parallel
        :rtype: List[:any:`PerfFlow`]
        """
        for client_nic, server_nic in self.generate_perf_endpoints(config):
            for ipv in self.params.ip_versions:
                for perf_test in self.params.perf_tests:
                    for size in self.params.perf_msg_sizes:
                        yield self._create_perf_flows(
                            perf_test,
                            ipv,
                            client_nic,
                            server_nic,
                            size,
                        )

    def generate_perf_endpoints(self, config):
        """Generator for perf endpoints

        To be overridden by a derived class.

        :return: list of device pairs
        :rtype: List[Tuple[:any:`Device`, :any:`Device`]]
        """
        return []

    def _create_perf_flows(
        self,
        perf_test,
        ipv,
        client_nic,
        server_nic,
        msg_size,
    ) -> List[PerfFlow]:

        ip_filter = {}
        if ipv == "ipv4":
            ip_filter.update(family=AF_INET)
        elif ipv == "ipv6":
            ip_filter.update(family=AF_INET6)
            ip_filter.update(is_link_local=False)

        client_ips = client_nic.ips_filter(**ip_filter)
        server_ips = server_nic.ips_filter(**ip_filter)

        flows = []
        port_offset=12000
        for i in range(self.params.perf_parallel_processes):
            flows.append(
                self._create_perf_flow(
                    perf_test,
                    client_nic,
                    client_ips[i % len(client_ips)],
                    port_offset + i,
                    server_nic,
                    server_ips[i % len(server_ips)],
                    port_offset + i,
                    msg_size,
                    self.generator_cpupin(i),
                    self.receiver_cpupin(i),
                )
            )

        return flows

    def generator_cpupin(self, process_no):
        """
        This method returns a list of cpus that will be used for CPU pinning
        of the flow generator. The method should be defined by derived class.
        """
        return None

    def receiver_cpupin(self, process_no):
        """
        This method returns a list of cpus that will be used for CPU pinning
        of the flow receiver. The method should be defined by derived class.
        """
        return None

    def _cpupin_based_on_policy(self, process_no=None, cpus=None, cpu_policy=None):
        """
        This is a helper method for any derived class that can be used by
        :any:`generator_cpupin` and :any:`receiver_cpupin` to generate
        a subset of `cpus` based on the `cpu_policy` and `process_no` parameters.

        :param process_no:
            This integer is used as wrapped index to the `cpus` list if
            `cpu_policy` is set to "round-robin". Typically a flow measurement
            generator iterates over the number of perf measurement tool instances
            and the iterator value is used as `process_no`

        :param cpus:
            A list of cpu ids available to select by `cpu_policy`

        :param cpu_policy:
            Can be set to following values:
            * "round-robin" - list containing single cpu with index `process_no`
            in the list defined by `cpus` is returned
            * "all" - complete list defined by the `cpus` is returned
        """
        if process_no is None:
            return None

        if not cpus:
            return None

        if not cpu_policy:
            return cpus

        if cpu_policy == 'round-robin':
            return [cpus[process_no % len(cpus)]]
        elif cpu_policy == 'all':
            return cpus
        else:
            raise Exception(f'Unknown cpu_policy {cpu_policy}')

    def _create_perf_flow(
        self,
        perf_test,
        client_nic,
        client_bind,
        client_port,
        server_nic,
        server_bind,
        server_port,
        msg_size,
        generator_cpupin,
        receiver_cpupin,
    ) -> PerfFlow:
        """
        Wrapper to create a PerfFlow. Mixins that want to change this behavior (for example, to reverse the direction)
        can override this method as an alternative to overriding :any:`generate_flow_combinations`
        """
        return PerfFlow(
            type=perf_test,
            generator=client_nic.netns,
            generator_bind=client_bind,
            generator_nic=client_nic,
            generator_port=client_port,
            receiver=server_nic.netns,
            receiver_bind=server_bind,
            receiver_nic=server_nic,
            receiver_port=server_port,
            msg_size=msg_size,
            duration=self.params.perf_duration,
            warmup_duration=self.params.perf_warmup_duration,
            parallel_streams=self.params.perf_parallel_streams,
            generator_cpupin=generator_cpupin,
            receiver_cpupin=receiver_cpupin,
        )
