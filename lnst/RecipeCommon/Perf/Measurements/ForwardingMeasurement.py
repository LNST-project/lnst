"""
Module implementing Forwarding Measurement.

Copyright 2025 Red Hat, Inc.
Licensed under the GNU General Public License, version 2 as
published by the Free Software Foundation; see COPYING for details.
"""

__author__ = """
sdobron@redhat.com (Samuel Dobron)
"""

import signal
from typing import Literal

from lnst.Tests.XDPBench import XDPBench
from lnst.RecipeCommon.Perf.Results import (
    PerfInterval,
    ParallelPerfResult,
    SequentialPerfResult,
)
from lnst.Devices.VlanDevice import VlanDevice
from lnst.Controller.RecipeResults import ResultType
from lnst.Tests.PktGen import PktgenController

from lnst.Tests.InterfaceStatsMonitor import InterfaceStatsMonitor
from lnst.RecipeCommon.Perf.Measurements.BaseFlowMeasurement import NetworkFlowTest
from lnst.RecipeCommon.Perf.Measurements.MeasurementError import MeasurementError
from lnst.RecipeCommon.Perf.Measurements.BaseFlowMeasurement import BaseFlowMeasurement
from lnst.RecipeCommon.Perf.Measurements.Results.ForwardingMeasurementResults import (
    ForwardingMeasurementResults,
)
from lnst.RecipeCommon.Perf.Measurements.Results.AggregatedForwardingMeasurementResults import (
    AggregatedForwardingMeasurementResults,
)
from lnst.Controller.RecipeResults import MeasurementResult


class ForwardingMeasurement(BaseFlowMeasurement):
    """
    This class implements the forwarding measurement.
    It uses pktgen to generate packets originating from
    :attr:`Flow.generator_nic` destinating :attr:`Flow.receiver_nic`
    via :attr:`Flow.forwarder_rx_nic` and :attr:`Flow.forwarder_tx_nic`.

    :attr:`Flow.receiver_nic` runs XDP-bench in drop mode.
    We could use some nftables rule but xdp-bench is much
    faster and requires less separate CPUs for dropping packets
    and so, we can use more CPUs for generating traffic.

    This class expects forwarding to be already configured.
    Underlying forwarding plane could be anything like regular
    kernel, xdp-forward, ...

    Since it's not possible to measure receiver and forwarder
    separately when multiple flows are used, this measurement
    uses different hierarchy for results. Generator is measured
    per flow while receiver and forwarder are measured per measurement.
    Thus, :attr:`ForwardingMeasurementResults.receiver_results`,
    :attr:`ForwardingMeasurementResults.forwarder_rx_results`,
    and :attr:`ForwardingMeasurementResults.forwarder_tx_results`
    contain results for all flows combined. Therefore, just
    a single :class:`ForwardingMeasurementResults` result object
    is returned per measurement (for all flows combined).

    :param ratep: Upper bound for packets per second generated by pktgen.
        This parameter is passed to the pktgen test module to limit the
        packet generation rate. Default is -1 (unlimited).
    :param burst: Number of copies of the same packet to send. This parameter
        is passed to the pktgen test module. Default is 1.
    """

    def __init__(
        self,
        flows,
        ratep=-1,
        burst=1,
        xdp_mode: Literal["skb", "native"] = "native",
        recipe_conf=None,
    ):
        super().__init__(recipe_conf=recipe_conf)
        self._flows = flows
        self._mode = xdp_mode
        self._ratep = ratep
        self._burst = burst

        self._generator_job = None  # pktgen
        self._dropper_job = None  # xdp-bench
        self._forwarder_rx_monitor_job = None  # interface stats monitor (RX)
        self._forwarder_tx_monitor_job = None  # interface stats monitor (TX)

        self._finished_generator_job = None
        self._finished_dropper_job = None
        self._finished_fwd_rx_monitor_job = None
        self._finished_fwd_tx_monitor_job = None

        self._net_flows = []

    @property
    def flows(self):
        return self._flows

    def start(self):
        # measurement doesn't support different flow paths:
        if not all(
            flow.receiver_nic == self.flows[0].receiver_nic for flow in self.flows
        ):
            raise MeasurementError("All flows must have the same receiver_nic")
        if not all(
            flow.forwarder_rx_nic == self.flows[0].forwarder_rx_nic
            for flow in self.flows
        ):
            raise MeasurementError("All flows must have the same forwarder_rx_nic")
        if not all(
            flow.forwarder_tx_nic == self.flows[0].forwarder_tx_nic
            for flow in self.flows
        ):
            raise MeasurementError("All flows must have the same forwarder_tx_nic")
        if not all(flow.generator == self.flows[0].generator for flow in self.flows):
            raise MeasurementError("Multiple generators are not supported")
        if not all(flow.duration == self.flows[0].duration for flow in self.flows):
            raise MeasurementError("All flows must have the same duration")
        if not all(
            flow.warmup_duration == self.flows[0].warmup_duration for flow in self.flows
        ):
            raise MeasurementError("All flows must have the same warmup duration")

        self._prepare_jobs()

        self._dropper_job.start(bg=True)
        self._forwarder_rx_monitor_job.start(bg=True)
        self._forwarder_tx_monitor_job.start(bg=True)
        self._generator_job.start(bg=True)

    def _prepare_jobs(self):
        self._generator_job = self._prepare_client()
        self._forwarder_rx_monitor_job, self._forwarder_tx_monitor_job = (
            self._prepare_forwarder()
        )
        self._dropper_job = self._prepare_server()

        for flow in self.flows:
            net_flow = NetworkFlowTest(flow, self._dropper_job, self._generator_job)
            net_flow.forwarder_rx_job = self._forwarder_rx_monitor_job
            net_flow.forwarder_tx_job = self._forwarder_tx_monitor_job

            self._net_flows.append(net_flow)

    def _prepare_client(self):
        config = []
        for flow in self.flows:
            config.append(
                {
                    "src_if": self._real_dev(flow.generator_nic),
                    "dst_mac": flow.forwarder_rx_nic.hwaddr,
                    "src_ip": flow.generator_bind,
                    "dst_ip": flow.receiver_bind,
                    "cpu": flow.generator_cpupin[
                        0
                    ],  # FwdMeasGen round-robins cpus, so this will be list with 1 cpu only
                    "pkt_size": flow.msg_size,
                    "duration": flow.duration + flow.warmup_duration * 2,
                    "src_port": flow.generator_port,
                    "dst_port": flow.receiver_port,
                    "ratep": int(
                        self._ratep / self._burst
                    ),  # pktgen internally does ratep * burst
                    # ^ ratep should be set, to prevent bandwidth starvation
                    "burst": self._burst,
                }
            )

        pktgen = PktgenController(config=config)

        job = self.flows[0].generator.prepare_job(pktgen)

        return job

    def _prepare_server(self):
        """
        Prepares xdp-bench in drop mode at the receiver.

        This is an easy way of counting and dropping packets
        afterwards. Any other solution would involve kernel
        which just slow things down...
        """
        sample_flow = self.flows[0]  # all flows have the same receiver_nic
        receiver_nic = self._real_dev(sample_flow.receiver_nic)

        params = {
            "command": "drop",
            "xdp_mode": self._mode,
            "interface": receiver_nic,
            "duration": sample_flow.duration + sample_flow.warmup_duration * 2,
        }
        bench = XDPBench(**params)
        job = sample_flow.receiver.prepare_job(bench)

        return job

    def _prepare_forwarder(self):
        """
        Prepares InterfaceStatsMonitor jobs at the forwarder for both RX and TX.

        Returns tuple of (rx_job, tx_job).
        """

        sample_flow = self.flows[0]
        forwarder_rx_nic = self._real_dev(sample_flow.forwarder_rx_nic)
        forwarder_tx_nic = self._real_dev(sample_flow.forwarder_tx_nic)

        rx_monitor = InterfaceStatsMonitor(
            device=forwarder_rx_nic,
            stats=["rx_packets"],
        )
        rx_job = sample_flow.forwarder_rx_nic.netns.prepare_job(rx_monitor)

        tx_monitor = InterfaceStatsMonitor(
            device=forwarder_tx_nic,
            stats=["tx_packets"],
        )
        tx_job = sample_flow.forwarder_tx_nic.netns.prepare_job(tx_monitor)

        return rx_job, tx_job

    def finish(self):
        try:
            self._generator_job.wait(
                timeout=self._generator_job.what.runtime_estimate()
            )
            self._forwarder_rx_monitor_job.kill(signal.SIGINT)
            self._forwarder_rx_monitor_job.wait()
            self._forwarder_tx_monitor_job.kill(signal.SIGINT)
            self._forwarder_tx_monitor_job.wait()
            self._dropper_job.wait(timeout=self._dropper_job.what.runtime_estimate())
        finally:
            self._generator_job.kill()
            self._forwarder_rx_monitor_job.kill()
            self._forwarder_tx_monitor_job.kill()
            self._dropper_job.kill()

        self._finished_generator_job = self._generator_job
        self._finished_dropper_job = self._dropper_job
        self._finished_fwd_rx_monitor_job = self._forwarder_rx_monitor_job
        self._finished_fwd_tx_monitor_job = self._forwarder_tx_monitor_job

        self._generator_job = None
        self._dropper_job = None
        self._forwarder_rx_monitor_job = None
        self._forwarder_tx_monitor_job = None

    def collect_results(self):
        receiver_results = self._parse_dropper_results()  # per measurement results
        forwarder_rx_results = self._parse_fwd_monitor_results(
            self._finished_fwd_rx_monitor_job, "rx_packets"
        )  # per measurement results
        forwarder_tx_results = self._parse_fwd_monitor_results(
            self._finished_fwd_tx_monitor_job, "tx_packets"
        )  # per measurement results
        generator_results = self._parse_generator_results()  # per stream results

        flows = [net_flow.flow for net_flow in self._net_flows]
        warmup_duration = flows[0].warmup_duration if flows else 0

        result = ForwardingMeasurementResults(
            measurement=self,
            measurement_success=bool(receiver_results)
            and bool(generator_results)
            and bool(forwarder_rx_results)
            and bool(forwarder_tx_results),
            flows=flows,
            warmup_duration=warmup_duration,
        )
        result.generator_results = generator_results
        result.receiver_results = receiver_results
        result.forwarder_rx_results = forwarder_rx_results
        result.forwarder_tx_results = forwarder_tx_results

        self._net_flows = []
        return [result]

    def _parse_generator_results(self) -> ParallelPerfResult:
        """
        pktgen results parser
        """
        nic_results = {}
        if not self._finished_generator_job.passed:
            return nic_results

        for nic, raw_results in self._finished_generator_job.result.items():
            instance_results = SequentialPerfResult()  # instance (device) of pktgen

            for raw_result in raw_results:
                sample = PerfInterval(
                    raw_result["packets"],
                    raw_result["duration"],
                    "packets",
                    raw_result["timestamp"],
                )
                instance_results.append(sample)

            nic_results[nic] = instance_results

        return ParallelPerfResult(nic_results.values())

    def _parse_dropper_results(self):
        """
        xdp-bench results parser
        """
        results = SequentialPerfResult()  # single instance of xdp-bench
        if not self._finished_dropper_job.passed:
            return results

        for sample in self._finished_dropper_job.result:
            results.append(
                PerfInterval(
                    sample["rx"], sample["duration"], "packets", sample["timestamp"]
                )
            )

        return results

    def _parse_fwd_monitor_results(self, finished_job, metric):
        """
        Parse forwarder results from the interface stats monitor.

        :param finished_job: The finished monitor job to parse results from
        :param metric: The metric name to parse (e.g., "rx_packets", "tx_packets")
        """
        result = SequentialPerfResult()
        if not finished_job.passed:
            return result

        raw_samples = finished_job.result
        unit = "packets"

        previous_timestamp = raw_samples[0]["timestamp"]
        previous_value = raw_samples[0][metric]

        for raw_sample in raw_samples[1:]:
            sample = PerfInterval(
                raw_sample[metric] - previous_value,
                raw_sample["timestamp"] - previous_timestamp,
                unit,
                raw_sample["timestamp"],
            )
            result.append(sample)

            previous_timestamp = raw_sample["timestamp"]
            previous_value = raw_sample[metric]

        return result

    def _real_dev(self, device):
        if isinstance(device, VlanDevice):
            return device.realdev
        # TODO: support for other soft devices

        return device

    def _aggregate_flows(self, old_flow, new_flow):
        if old_flow is None:
            return new_flow

        if isinstance(old_flow, AggregatedForwardingMeasurementResults):
            old_flow.add_results(new_flow)
            return old_flow
        else:
            new_result = AggregatedForwardingMeasurementResults(
                measurement=self, flows=new_flow.flows
            )
            new_result.add_results(old_flow)
            new_result.add_results(new_flow)
            return new_result

    @classmethod
    def _report_flow_results(cls, recipe, result):
        generator = result.generator_results
        receiver = result.receiver_results
        forwarder_rx = result.forwarder_rx_results
        forwarder_tx = result.forwarder_tx_results

        desc = []
        desc.append(result.describe())

        metrics_result = ResultType.PASS
        metrics = {
            "Generator": generator,
            "Receiver": receiver,
            "Forwarder RX": forwarder_rx,
            "Forwarder TX": forwarder_tx,
        }
        data = {
            "generator_results": generator,
            "receiver_results": receiver,
            "forwarder_rx_results": forwarder_rx,
            "forwarder_tx_results": forwarder_tx,
        }

        for name, metric_result in metrics.items():
            if cls._invalid_flow_duration(metric_result):
                metrics_result = ResultType.FAIL
                desc.append("{} has invalid duration!".format(name))

        recipe_result = MeasurementResult(
            "forwarding",
            result=(
                ResultType.PASS
                if result.measurement_success and metrics_result
                else ResultType.FAIL
            ),
            description="\n".join(desc),
            data=data,
        )
        recipe.add_custom_result(recipe_result)

    @staticmethod
    def aggregate_multi_flow_results(results):
        """
        With the new structure, results are already aggregated per measurement.
        This method just returns the results as-is. Basically, this should never
        be called for ForwardingMeasurement.
        """
        if len(results) == 1:
            return results
        raise MeasurementError(
            "ForwardingMeasurement.aggregate_multi_flow_results called with multiple "
            "results! ForwardingMeasurement should produce single result per measurement "
            "(already aggregated)."
        )
